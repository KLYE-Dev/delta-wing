Vector = function(x1, x2, y1, y2) {

	var dx = x2 - x1;
	var dy = y2 - y1;

	this.mag = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

	this.x = dx / this.mag;
	this.y = dy / this.mag;

};

function getDistance(obj1, obj2) {

	return Math.sqrt(Math.pow(obj1.position.x - obj2.position.x, 2) + Math.pow(obj1.position.y - obj2.position.y, 2));

}

function getAngle(x1, x2, y1, y2) {
	var angle;

	if (x1 == x2) {
		if (y1 < y2) { return 0; }
		else { return 180 * (Math.PI/180); }
	}
	else {
		angle = Math.atan((y2-y1)/(x2-x1));
		if (x1 < x2) {
			return angle - 90 * (Math.PI/180);
		}
		else {
			return angle + 90 * (Math.PI/180);
		}
	}
}
;
(function() {
	window.game = {
		width: window.innerWidth,
		height: window.innerHeight,
		state: 'menu',
		chunks: {},
		planets: [],

		init: function() {

			// game.loader = new PIXI.AssetLoader([
			// 	"Spritesheet.json",
			// 	"background.png"
			// ]);

			game.loader = new THREE.JSONLoader();

			// game.loader.onComplete = game.assetsLoaded;

			game.mouse = {
				position: {
					x: 0,
					y: 0
				}
			};

			// var interactive = true;
			// game.stage = new PIXI.Stage(0x000000, interactive);
			game.scene = new THREE.Scene();
			game.camera = new THREE.PerspectiveCamera(90, game.width / game.height, 0.1, 1000);
			game.camera.position.y = 150;

			var axisHelper = new THREE.AxisHelper( 5 );
			game.scene.add( axisHelper );

			var light = new THREE.AmbientLight( 0x404040 );
			game.scene.add( light );

			window.addEventListener('keyup', function(event) { game.key.onKeyup(event); }, false);
			window.addEventListener('keydown', function(event) { game.key.onKeydown(event); }, false);

			game.scene.mousemove = function(data) {
				var newPosition = data.getLocalPosition(this);
				//console.log(newPosition.x + ', ' + newPosition.y);
				game.mouse.position.x = newPosition.x;
				game.mouse.position.y = newPosition.y;
			};

			game.scene.click = function(data) {
				if (game.ship.state == 'ready') {
					game.aimLine.visible = false;
					game.ship.state = 'launched';

					game.ship.thrust = getDistance(game.mouse, game.aimLine) / 50;

					var vector = new Vector(game.aimLine.position.x, game.mouse.position.x,
											game.aimLine.position.y, game.mouse.position.y);

					game.ship.velocity.x = vector.x * game.ship.thrust;
					game.ship.velocity.y = vector.y * game.ship.thrust;

					mag = Math.sqrt(this.deltaX * this.deltaX + this.deltaY * this.deltaY);
				}
			};

			game.scene.mousedown = function(data) {
				if (game.ship.state == 'idle') {
					game.dragging = true;
				}
				else if (game.ship.state == 'launched') {
					//game.ship.rocketThrust = 10;
				}
			};

			game.scene.mouseup = function(data) {
				if (game.ship.state == 'idle') {
					game.dragging = false;
				}
				else if (game.ship.state == 'launched') {
					//game.ship.rocketThrust = 0;
				}
			};

			// create a renderer instance.
    		// game.renderer = PIXI.autoDetectRenderer(game.width, game.height);
    		game.renderer = new THREE.WebGLRenderer();
    		game.renderer.setSize( game.width, game.height );

    		controls = new THREE.OrbitControls( game.camera, game.renderer.domElement );

    		// add the renderer view element to the DOM
    		document.body.appendChild(game.renderer.domElement);

    		//game.level = new PIXI.DisplayObjectContainer();
    		game.level = new THREE.Object3D();
    		// game.level.position.x = 0;
    		// game.level.position.y = 0;
    		game.scene.add(game.level);

    		game.loader.load("assets/ship/ship.js", game.assetsLoaded);
		}
	};

	game.key = {
		_pressed: {},

		LEFT: 65,
		UP: 87,
		RIGHT: 68,
		DOWN: 83,
		TAB: 9,
		ENTER: 13,

		isDown: function(keyCode) {
			return this._pressed[keyCode];
		},

		onKeydown: function(event) {
			this._pressed[event.keyCode] = true;
			if (event.keyCode == game.key.TAB) {
				event.preventDefault();
				return false;
			}
		},

		onKeyup: function(event) {
			delete this._pressed[event.keyCode];
		}
	};

	window.onload = function() {
		// Start the Game
		game.init();
	};
})();
;
(function() {

	game.assetsLoaded = function(geometry, materials) {
		// Connect to server
		//game.socket = game.network.connect();
		//game.network.setEventHandlers();

		// game.backgroundTexture = new PIXI.Texture.fromImage('background.png');
		// game.background = new PIXI.TilingSprite(game.backgroundTexture, game.width, game.height);
		// game.background.position.x = 0;
		// game.background.position.y = 0;
		// game.background.tilePosition.x = 0;
		// game.background.tilePosition.y = 0;
		// game.stage.addChild(game.background);

		// game.midgroundTexture = new PIXI.Texture.fromImage('midground.png');
		// game.midground = new PIXI.TilingSprite(game.midgroundTexture, game.width, game.height);
		// game.midground.position.x = 0;
		// game.midground.position.y = 0;
		// game.midground.tilePosition.x = 0;
		// game.midground.tilePosition.y = 0;
		// game.stage.addChild(game.midground);

		// game.stage.addChild(game.level);

		// game.ship = new PIXI.Sprite.fromImage('fighter.png');

		game.camera.position.z = 5;

		materials = new THREE.MeshBasicMaterial( { color: 0xdddddd } );

		//materials = new THREE.MeshFaceMaterial( materials );

		game.ship = new THREE.Mesh( geometry, materials );

		game.ship.position.x = 0;
		game.ship.position.y = 0;
		// game.ship.anchor.x = 0.5;
		// game.ship.anchor.y = 0.5;
		game.ship.scale.x = 1;
		game.ship.scale.y = 1;
		game.ship.radius = 30 * game.ship.scale.x;
		game.ship.mass = 1;
		game.ship.thrust = 0.2;
		game.ship.velocity = {
			x: 0,
			y: 0
		};
		game.ship.vector = {
			x: 0,
			y: 0
		};
		game.ship.state = 'launched';
		game.level.add(game.ship);

		requestAnimationFrame(game.run);

	};

	game.loadSurroudingChunks = function(x, y) {
		game.chunkBuffer = 1;

		for (var xx = -game.chunkBuffer; xx <= game.chunkBuffer; xx++) {
			for (var yy = -game.chunkBuffer; yy <= game.chunkBuffer; yy++) {
				var chunkX = xx + x;
				var chunkY = yy + y;
				game.socket.emit('get chunk', { x: chunkX, y: chunkY });
			}
		}
	};

	game.run = function() {
		requestAnimationFrame(game.run);
		game.update();
		game.renderer.render(game.scene, game.camera);
	};

	game.update = function() {
		// game.background.tilePosition.x -= 0.2 * game.ship.velocity.x;
		// game.midground.tilePosition.x -= 0.4 * game.ship.velocity.x;
		// game.background.tilePosition.y -= 0.2 * game.ship.velocity.y;
		// game.midground.tilePosition.y -= 0.4 * game.ship.velocity.y;

		game.level.position.x -= 0.5 * game.ship.velocity.x;
		game.level.position.y -= 0.5 * game.ship.velocity.y;

		game.ship.rotation = getAngle(game.mouse.position.x, game.ship.position.x, game.mouse.position.y, game.ship.position.y);

		if (game.ship.state === 'launched') {
			for (var p = 0; p < game.planets.length; p++) {
		 		//var distance = getDistance(game.planets[p], game.level);
		 		var distance = Math.sqrt(Math.pow(game.planets[p].position.x + (-game.ship.position.x + game.level.position.x), 2) + Math.pow(game.planets[p].position.y + (-game.ship.position.y + game.level.position.y), 2));
		 		if (p === 0) {
		 			//console.log(distance);
		 		}

		 		var planetVector = new Vector(game.ship.position.x, game.planets[p].position.x,
		 								game.ship.position.y, game.planets[p].position.y);

		// 		var topSpeed = 10;

		// 		var gravitationalForce = (game.gravity * game.ship.mass * game.planets[p].mass)/Math.pow(distance,2);

				if (distance < game.ship.radius + game.planets[p].radius) {
					//game.ship.state = 'colliding';
					/*if (game.planets[p].target == 'true') {
						game.explosion.onComplete = function() { game.win(); }
					}*/

					console.log('colliding');

					game.ship.vector.x = -planetVector.x;
					game.ship.vector.y = -planetVector.y;
				}
		// 		else {
		// 			game.ship.vector.x += planetVector.x * gravitationalForce;
		// 			game.ship.vector.y += planetVector.y * gravitationalForce;
		// 		}

		// 		if (Math.abs(game.ship.vector.x) > topSpeed) {
		// 			game.ship.vector.x = (Math.abs(game.ship.vector.x)/game.ship.vector.x) * topSpeed;
		// 		}
		// 		if (Math.abs(game.ship.vector.y) > topSpeed) {
		// 			game.ship.vector.y = (Math.abs(game.ship.vector.y)/game.ship.vector.y) * topSpeed;
		// 		}

		// 		game.planets[p].position.x -= game.ship.velocity.x;
		// 		game.planets[p].position.y -= game.ship.velocity.y;
		// 		game.shadows[p].position.x -= game.ship.velocity.x;
		// 		game.shadows[p].position.y -= game.ship.velocity.y;
			}

			var mouseVector = new Vector(game.ship.position.x, game.mouse.position.x,
										game.ship.position.y, game.mouse.position.y);

			var acceleration = 0.05;

			if (game.key.isDown(game.key.UP)) {
				game.ship.vector.x += mouseVector.x * acceleration;
				game.ship.vector.y += mouseVector.y * acceleration;
			}
			if (game.key.isDown(game.key.DOWN)) {
				game.ship.vector.x -= mouseVector.x * acceleration;
				game.ship.vector.y -= mouseVector.y * acceleration;
			}

			game.ship.velocity.x = game.ship.vector.x;
			game.ship.velocity.y = game.ship.vector.y;

		}
		else if (game.ship.state == 'colliding') {
			if (!game.explosion.playing) {
				game.ship.visible = false;
				game.ship.velocity.x = 0;
				game.ship.velocity.y = 0;
				game.explosion.position.x = game.ship.position.x;
				game.explosion.position.y = game.ship.position.y;
				game.explosion.visible = true;
				game.explosion.gotoAndPlay(0);
			}
		}
		else {
			
		// 	if (game.dragging === true && game.level.position.x <= 0) {
		// 		game.level.position.x -= (game.lastMousePosition - game.mouse.position.x) * 2;
		// 		if (game.level.position.x > 0) {
		// 			game.level.position.x = 0;
		// 		}
				
		// 	}
		// 	game.lastMousePosition = game.mouse.position.x;

		// 	game.ship.click = function(data) {
		// 		if (game.ship.state == 'idle') {
		// 			game.aimLine.visible = true;
		// 			game.ship.state = 'ready';
		// 		}
		// 		else if (game.ship.state == 'ready') {
		// 			game.aimLine.visible = false;
		// 			game.ship.state = 'idle';
		// 		}
		// 	}
		// }

		// game.gutter = 200;

		// if (game.ship.position.x < -game.gutter || game.ship.position.x > (game.level.json.width * game.level.json.tilewidth) + game.gutter ||
		// 	game.ship.position.y < -game.gutter || game.ship.position.y > (game.level.json.height * game.level.json.tileheight) + game.gutter) {
			
		// 	game.reset();
		
		}
	};

})();;
(function() {

	var socket;

	game.network = {

		connect: function() {
			socket = io.connect(window.location.href);
			return socket;
		},

		setEventHandlers: function() {
			socket.on('connect', this.onSocketConnected);
			socket.on('client id', this.onClientId);
			socket.on('disconnect', this.onSocketDisconnect);
			socket.on('new player', this.onNewPlayer);
			socket.on('move player', this.onMovePlayer);
			socket.on('remove player', this.onRemovePlayer);
			socket.on('new projectile', this.onNewProjectile);
			socket.on('remove projectile', this.onRemoveProjectile);
			socket.on('deaths', this.onDeaths);
			socket.on('kills', this.onKills);
			socket.on('chunk', this.onChunk);
			socket.on('spawn', this.onSpawn);
		},

		onSpawn: function(data) {
			console.log('spawn coordinates recieved at (' + data.x + ', ' + data.y + ')');
			game.loadSurroudingChunks(data.x, data.y);
		},

		onChunk: function(data) {
			var coords = data.x + ',' + data.y;

			game.chunks[coords] = data.json;

			for (var c = 0; c < data.json.layers.length; c++) {
				for (var o = 0; o < data.json.layers[c].objects.length; o++) {
					var yMultiplier = data.json.height * data.json.tileheight * data.json.y;
					var xMultiplier = data.json.width * data.json.tilewidth * data.json.x;
					var planet = PIXI.Sprite.fromImage(data.json.layers[c].objects[o].properties.texture);
					planet.position.x = xMultiplier + data.json.layers[c].objects[o].x;
					planet.position.y = yMultiplier + data.json.layers[c].objects[o].y;
					planet.anchor.x = 0.5;
					planet.anchor.y = 0.5;
					planet.height = data.json.layers[c].objects[o].height;
					planet.width = data.json.layers[c].objects[o].width;
					planet.radius = data.json.layers[c].objects[o].width/2;
					game.planets.push(planet);
					game.level.addChild(planet);
				}
			}
		},

		onSocketConnected: function() {
			console.log('Connected to socket server, requesting client id');
			game.socket.emit('request id', {});
			//game.loadChunks();
		},

		onClientId: function(data) {
			game.clientId = data.id;
			console.log('network id acquired: ' + game.clientId);

			/*game.entities[game.clientId] = game.createEntity({
				playerId: game.clientId,
				image: game.loader.getAsset('fighter.png'),
				x: game.entities['map'].width/2,
				y: game.entities['map'].height/2,
				screenX: game.width/2,
				screenY: game.height/2,
				angle: 0,
				offsetX: -game.assetManager.getAsset('fighter.png').width/2,
				offsetY: -game.assetManager.getAsset('fighter.png').height/2,
				collision: 'circle',
				zIndex: 2
			}, [game.component.entity,
				game.component.moveable,
				game.component.damageable]);*/



			console.log('requesting already connected players.');
			game.socket.emit('get clients', {});
			console.log('requesting spawn coordinates');
			game.socket.emit('get spawn', {});
			game.lastUpdate = Date.now();
			//game.run();
		},

		onSocketDisconnect: function() {
			console.log('Disconnected from socket server');
		},

		onNewPlayer: function(data) {
			console.log('New player connected: ' + data.id + ':' + data.name);

			game.entities[data.id] = game.createEntity({
				playerId: data.id,
				name: data.name,
				image: game.assetManager.getAsset('fighter.png'),
				x: data.x,
				y: data.y,
				r: 20,
				angle: 0,
				offsetX: -game.assetManager.getAsset('fighter.png').width/2,
				offsetY: -game.assetManager.getAsset('fighter.png').height/2,
				width: game.assetManager.getAsset('fighter.png').width,
				height: game.assetManager.getAsset('fighter.png').height,
				collision: 'circle',
				zIndex: 2,
				kills: data.kills,
				deaths: data.deaths
			}, [game.component.entity,
				game.component.moveable,
				game.component.drawable]);

			game.nPlayers++;

			game.addPlayerToScoreboard(game.entities[data.id]);
		},

		onMovePlayer: function(data) {
			game.entities[data.id].screenX = data.x - game.entities[game.clientId].x + game.entities[game.clientId].screenX;
			game.entities[data.id].screenY = data.y - game.entities[game.clientId].y + game.entities[game.clientId].screenY;
			game.entities[data.id].x = data.x;
			game.entities[data.id].y = data.y;
			game.entities[data.id].velX = data.velX;
			game.entities[data.id].velY = data.velY;
			game.entities[data.id].angle = data.angle;
		},

		onRemovePlayer: function(data) {
			if (!game.entities[data.id]) {
				console.log('Player not found: ' + data.id);
				return;
			}

			game.removePlayerFromScoreboard(game.entities[data.id]);
			delete game.entities[data.id];
			game.nPlayers--;
			console.log('player has been disconnected: ' + data.id);
		},

		onNewProjectile: function(data) {
			game.entities['Projectile' + data.id] = game.createEntity({
				id: data.id,
				image: game.assetManager.getAsset('projectile.png'),
				playerId: data.playerId,
				x: data.x,
				y: data.y,
				velX: data.velX,
				velY: data.velY,
				collision: 'circle',
				dp: 1,
				zIndex: 1
			}, [game.component.entity,
				game.component.moveable,
				game.component.drawable,
				game.component.projectile]);
		},

		onRemoveProjectile: function(data) {
			var removeProjectile = projectileById(data.id);

			if (!removeProjectile) {
				console.log('Projectile not found: ' + this.id);
			}

			game.projectiles.splice(game.projectiles.indexOf(removeProjectile));
		},

		onDeaths: function(data) {
			game.entities[data.id].deaths = data.deaths;
			game.entities[data.id + '.deathsLabel'].label = game.entities[data.id].deaths;
		},

		onKills: function(data) {
			game.entities[data.id].kills = data.kills;
			game.entities[data.id + '.killsLabel'].label = game.entities[data.id].kills;
		}

	};

}());
